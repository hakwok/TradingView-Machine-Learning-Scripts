// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © hkwo
//@version=5
strategy("kNN ML EMA Ribbon Trend Forecast Strategy", initial_capital=100000, default_qty_type=strategy.percent_of_equity, max_lines_count=200, default_qty_value=100, pyramiding=0, currency='USD', overlay=true, format=format.price, precision=2)

//!!!!!!!!!!!!!!!!!!!STRATEGY!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!STOP/LOSS TAKE/PROFIT Parameters!!!!!!!!!!!!!!!!!
//// Stoploss and Take Profit Parameters
// Enable Long Strategy
enable_long_strategy = input.bool(true, title='Enable Long Strategy', group='SL/TP For Long Strategy', inline='1')
long_stoploss_value = input.float(defval=50, title='Stoploss %', minval=0, group='SL/TP For Long Strategy', inline='2')
long_stoploss_percentage = close * (long_stoploss_value / 100) / syminfo.mintick
long_takeprofit_value = input.float(defval=50, title='Take Profit %', minval=0, group='SL/TP For Long Strategy', inline='2')
long_takeprofit_percentage = close * (long_takeprofit_value / 100) / syminfo.mintick

// Enable Short Strategy
enable_short_strategy = input.bool(true, title='Enable Short Strategy', group='SL/TP For Short Strategy', inline='3')
short_stoploss_value = input.float(defval=50, title='Stoploss %', minval=0, group='SL/TP For Short Strategy', inline='4')
short_stoploss_percentage = close * (short_stoploss_value / 100) / syminfo.mintick
short_takeprofit_value = input.float(defval=50, title='Take Profit %', minval=0, group='SL/TP For Short Strategy', inline='4')
short_takeprofit_percentage = close * (short_takeprofit_value / 100) / syminfo.mintick

// Plot Stoploss & Take Profit Levels
long_stoploss_price = strategy.position_avg_price * (1 - long_stoploss_value / 100)
long_takeprofit_price = strategy.position_avg_price * (1 + long_takeprofit_value / 100)
short_stoploss_price = strategy.position_avg_price * (1 + short_stoploss_value / 100)
short_takeprofit_price = strategy.position_avg_price * (1 - short_takeprofit_value / 100)
plot(enable_long_strategy and not enable_short_strategy ? long_stoploss_price : na, color=color.new(#ff0000, 0), style=plot.style_linebr, linewidth=2, title='Long SL Level')
plot(enable_long_strategy and not enable_short_strategy ? long_takeprofit_price : na, color=color.new(#008000, 0), style=plot.style_linebr, linewidth=2, title='Long TP Level')
plot(enable_short_strategy and not enable_long_strategy ? short_stoploss_price : na, color=color.new(#ff0000, 0), style=plot.style_linebr, linewidth=2, title='Short SL Level')
plot(enable_short_strategy and not enable_long_strategy ? short_takeprofit_price : na, color=color.new(#008000, 0), style=plot.style_linebr, linewidth=2, title='Short TP Level')


// Trendlines With Breaks
length = input.int(14)
k      = input.float(1.,'Slope',minval=0,step=.1)
method = input.string('Atr','Slope Calculation Method',options=['Atr','Stdev','Linreg'])
show   = input(true,'Show Only Confirmed Breakouts')
//----
upper = 0.,lower = 0.
slope_ph = 0.,slope_pl = 0.
src = close
n = bar_index
//----
ph = ta.pivothigh(length,length)
pl = ta.pivotlow(length,length)
slope = switch method
    'Atr'      => ta.atr(length)/length*k
    'Stdev'    => ta.stdev(src,length)/length*k
    'Linreg'   => math.abs(ta.sma(src*bar_index,length)-ta.sma(src,length)*ta.sma(bar_index,length))/ta.variance(n,length)/2*k

slope_ph := ph ? slope : slope_ph[1]
slope_pl := pl ? slope : slope_pl[1]

upper := ph ? ph : upper[1] - slope_ph
lower := pl ? pl : lower[1] + slope_pl
//----
single_upper = 0
single_lower = 0
single_upper := src[length] > upper ? 0 : ph ? 1 : single_upper[1]
single_lower := src[length] < lower ? 0 : pl ? 1 : single_lower[1]
upper_breakout = single_upper[1] and src[length] > upper and (show ? src > src[length] : 1)
lower_breakout = single_lower[1] and src[length] < lower and (show ? src < src[length] : 1)
plotshape(upper_breakout ? low[length] : na,"Upper Break",shape.labelup,location.absolute,#26a69a,-length,text="B",textcolor=color.white,size=size.tiny)
plotshape(lower_breakout ? high[length] : na,"Lower Break",shape.labeldown,location.absolute,#ef5350,-length,text="B",textcolor=color.white,size=size.tiny)
//----
var line up_l = na
var line dn_l = na
var label recent_up_break = na
var label recent_dn_break = na

if ph[1]
    line.delete(up_l[1])
    label.delete(recent_up_break[1])
    
    up_l := line.new(n-length-1,ph[1],n-length,upper,color=#26a69a,
      extend=extend.right,style=line.style_dashed)
if pl[1]
    line.delete(dn_l[1])
    label.delete(recent_dn_break[1])
    
    dn_l := line.new(n-length-1,pl[1],n-length,lower,color=#ef5350,
      extend=extend.right,style=line.style_dashed)

bool confirmedUpperBreak = false
bool confirmedLowerBreak = false

if ta.crossover(src,upper-slope_ph*length)
    label.delete(recent_up_break[1])
    recent_up_break := label.new(n,low,'B',color=#26a69a,textcolor=color.white,style=label.style_label_up,size=size.small)
    confirmedUpperBreak := true

if ta.crossunder(src,lower+slope_pl*length)
    label.delete(recent_dn_break[1])
    recent_dn_break := label.new(n,high,'B',color=#ef5350,textcolor=color.white,style=label.style_label_down,size=size.small)
    confirmedLowerBreak := true
    
//----
plot(upper,'Upper',color = ph ? na : #26a69a,offset=-length)
plot(lower,'Lower',color = pl ? na : #ef5350,offset=-length)


// EMA Ribbon
int   i_length   = input(21, "Length", '2')
color i_c_maBull = input(color.rgb(50, 255, 50), "Bull")
color i_c_maBear = input(color.rgb(255, 50, 50), "Bear")
float ma = ta.ema(close, i_length)
// Define our states.
bool maRising  = ta.rising(ma, 1)
// Build our color.
color c_ma = maRising ? i_c_maBull : i_c_maBear
plot(ma, "MA 1", c_ma, 2)

int   i_length2   = input(25, "Length", '2')
color i_c_maBull2 = input(color.rgb(50, 255, 50, 20), "Bull")
color i_c_maBear2 = input(color.rgb(255, 50, 50, 20), "Bear")
float ma2 = ta.ema(close, i_length2)
// Define our states.
bool maRising2  = ta.rising(ma2, 1)
// Build our color.
color c_ma2 = maRising2 ? i_c_maBull2 : i_c_maBear2
plot(ma2, "MA 2", c_ma2, 2)

int   i_length3   = input(30, "Length", '2')
color i_c_maBull3 = input(color.rgb(50, 255, 50, 30), "Bull")
color i_c_maBear3 = input(color.rgb(255, 50, 50, 30), "Bear")
float ma3 = ta.ema(close, i_length3)
// Define our states.
bool maRising3  = ta.rising(ma3, 1)
// Build our color.
color c_ma3 = maRising3 ? i_c_maBull3 : i_c_maBear3
plot(ma3, "MA 3", c_ma3, 2)

int   i_length4   = input(35, "Length", '2')
color i_c_maBull4 = input(color.rgb(50, 255, 50, 40), "Bull")
color i_c_maBear4 = input(color.rgb(255, 50, 50, 40), "Bear")
float ma4 = ta.ema(close, i_length4)
// Define our states.
bool maRising4  = ta.rising(ma4, 1)
// Build our color.
color c_ma4 = maRising4 ? i_c_maBull4 : i_c_maBear4
plot(ma4, "MA 4", c_ma4, 2)

int   i_length5  = input(40, "Length", '2')
color i_c_maBull5 = input(color.rgb(50, 255, 50, 50), "Bull")
color i_c_maBear5 = input(color.rgb(255, 50, 50, 50), "Bear")
float ma5 = ta.ema(close, i_length5)
// Define our states.
bool maRising5  = ta.rising(ma5, 1)
// Build our color.
color c_ma5 = maRising5 ? i_c_maBull5 : i_c_maBear5
plot(ma5, "MA 5", c_ma5, 2)

int   i_length6   = input(45, "Length", '2')
color i_c_maBull6 = input(color.rgb(50, 255, 50, 60), "Bull")
color i_c_maBear6 = input(color.rgb(255, 50, 50, 60), "Bear")
float ma6 = ta.ema(close, i_length2)
// Define our states.
bool maRising6  = ta.rising(ma6, 1)
// Build our color.
color c_ma6 = maRising6 ? i_c_maBull6 : i_c_maBear6
plot(ma6, "MA 6", c_ma6, 2)

int   i_length7   = input(50, "Length", '2')
color i_c_maBull7 = input(color.rgb(50, 255, 50, 70), "Bull")
color i_c_maBear7 = input(color.rgb(255, 50, 50, 70), "Bear")
float ma7 = ta.ema(close, i_length7)
// Define our states.
bool maRising7  = ta.rising(ma7, 1)
// Build our color.
color c_ma7 = maRising7 ? i_c_maBull7 : i_c_maBear7
plot(ma7, "MA 7", c_ma7, 2)

int   i_length8   = input(200, "Length", '2')
color i_c_ma8 = input(color.rgb(238, 255, 0), "Bull")
float ma8 = ta.ema(close, i_length8)
// Define our states.
bool maRising8  = ta.rising(ma8, 1)
plot(ma8, "MA 8", i_c_ma8, 2)


//ML kNN Forecast
// Machine Learning Inputs
resolution = input.timeframe('60', 'Resolution', ['1', '3', '5', '10', '15', '30', '45', '60', '120', '180', '240', '480', 'D', 'W', 'M'])
numDataPoints = input.int(10, '# of Data Points [2:n]', 2)
numNearestNeighbors = input.int(100, '# of Nearest Neighbors [1:252]', 1, 252)
adjustPrediction = input.bool(true, 'Adjust Prediction', inline='b')
nonRepainting = input.bool(true, 'Non-Repainting', inline='b')
useMachineLearning = input.bool(true, 'Machine Learning', inline='b')
useEuclideanDistance = input.bool(true, 'Euclidean', inline='b')
projectionBase = input.source(hlcc4, 'Projection Base')

// Forecast Line Inputs
evaluationWindowLength = input.int(100, 'Evaluation Window', minval=0, maxval=200)
forecastWindowLength = input.int(100, 'Forecast Window', minval=1, maxval=200)
forecastMode = input.string('Similarity', 'Forecast Mode', options=['Similarity', 'Dissimilarity'])
forecastConstructionMethod = input.string('Cumulative', 'Forecast Construction', options=['Cumulative', 'Mean', 'Linreg'])
sourceData = input(close)
forecastColor = input(#f2ff41, 'Forecast Style', inline='fcast_style', group='Style')
forecastLineStyle = input.string('· · ·', '', options=['──', '- - -', '· · ·'], inline='fcast_style', group='Style')

// kNN Function
getNearestNeighbors(data) =>
    nearestNeighbors = array.new_float(0)
    distances = array.new_float(0)

    for i = 0 to numDataPoints - 1
        float distance = useEuclideanDistance ? math.sqrt(math.pow(data[i] - data[i + 1], 2)) : math.abs(data[i] - data[i + 1])
        array.push(distances, distance)
        int size = array.size(distances)
        float newNeighbor = distance < array.min(distances, size > numNearestNeighbors ? numNearestNeighbors : 0) ? data[i + 1] : data[i]
        array.push(nearestNeighbors, newNeighbor)

    nearestNeighbors

// Processing
repaintingOffset = nonRepainting ? 1 : 0
[openData, highData, lowData, closeData] = request.security('', resolution, [open, high[repaintingOffset], low[repaintingOffset], close[repaintingOffset]])
nearestNeighborData = getNearestNeighbors(closeData)

float prediction = array.avg(nearestNeighborData)

// Forecast line
// Variable Declarations & Initializing Lines
var forecastLines = array.new_line(0)
if barstate.isfirst
    for i = 0 to forecastWindowLength - 1
        array.push(forecastLines, line.new(na, na, na, na, style=forecastLineStyle == '- - -' ? line.style_dashed : forecastLineStyle == '· · ·' ? line.style_dotted : line.style_solid, color=forecastColor))
currentIndex = bar_index

// d value inputs
dataChanges = useMachineLearning ? ta.change(prediction) : ta.change(sourceData)

// Define an array to store forecasted values
var forecastedValues = array.new_float(0)

/// Calculate Forecast
if barstate.islast
    windowOffset = 0
    float maxValue = na
    calculationWindow = array.new_float(0)
    independentVariable = array.new_int(0)

    // Populate calculation window
    for i = 0 to forecastWindowLength * 2 + evaluationWindowLength
        calculationWindow.push(sourceData[i])

        // Populate independent variable array
        if forecastConstructionMethod == 'Linreg'
            independentVariable.push(currentIndex[i])

    referenceWindow = calculationWindow.slice(0, forecastWindowLength - 1)

    // Find window to produce forecast
    for i = 0 to evaluationWindowLength - 1
        evaluationWindow = calculationWindow.slice(forecastWindowLength + i, forecastWindowLength * 2 + i - 1)
        correlation = referenceWindow.covariance(evaluationWindow) / (referenceWindow.stdev() * evaluationWindow.stdev())

        // Maximization or minimization problem
        if forecastMode == 'Similarity'
            maxValue := correlation >= nz(maxValue, correlation) ? correlation : maxValue
        else
            maxValue := correlation <= nz(maxValue, correlation) ? correlation : maxValue

        windowOffset := maxValue == correlation ? i : windowOffset

    // Set ECHO
    previousValue = sourceData
    currentValue = sourceData
    for i = 0 to forecastWindowLength - 1
        forecastValue = dataChanges[forecastWindowLength + windowOffset + (forecastWindowLength - i - 1)]

        // Get forecast point
        if forecastConstructionMethod == 'Mean'
            currentValue := array.avg(referenceWindow) + forecastValue
        else if forecastConstructionMethod == 'Linreg'
            referenceWindow = calculationWindow.slice(0, forecastWindowLength)
            xValues = independentVariable.slice(0, forecastWindowLength)

            alpha = referenceWindow.covariance(xValues) / xValues.variance()
            beta = referenceWindow.avg() - alpha * xValues.avg()
            currentValue := alpha * (currentIndex + i + 1) + beta + forecastValue
        else
            currentValue += forecastValue

        // Store the forecast value in the array
        forecastedValues.push(currentValue)

        lineObj = forecastLines.get(i)
        lineObj.set_xy1(currentIndex + i, previousValue)
        lineObj.set_xy2(currentIndex + i + 1, currentValue)

        previousValue := currentValue


//!!!!!WIP!!!!! Entry condition based on predicted price at the last predicted bar 
var float lastNearestNeighbor = array.get(forecastedValues, array.size(forecastedValues) - 1)

var float upperMargin = 1.1
var float lowerMargin = 0.9

//currently prediction is the variable being used as the forecast estimate. However, for a more accurate prediction lastNearestNeighbor will more accurately represent the predicted line.
if prediction * ma8 > close * upperMargin and confirmedUpperBreak and close > ma
    strategy.entry("Long", strategy.long)
    strategy.exit("Long Exit", "Long", stop=long_stoploss_price, limit=long_takeprofit_price)
if prediction * (1/ma8) < close * lowerMargin and confirmedLowerBreak and close < ma
    strategy.entry("Short", strategy.short)
    strategy.exit("Short Exit", "Short", stop=short_stoploss_price, limit=short_takeprofit_price)
if prediction * (1/ma8) < close * lowerMargin and confirmedLowerBreak and close < ma
    strategy.close("Long")
if prediction * ma8 > close * upperMargin and confirmedUpperBreak and close > ma
    strategy.close("Short")